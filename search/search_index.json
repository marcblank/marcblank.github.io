{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>The Sequencer Powerups plugin for NINA contains a variety of useful instructions that enhance the power of the NINA's Advanced Sequencer.  The set of these instructions is expected to increase over time; consider them 'utility' instructions.  Many of these instructions allow you to take arbitrary sets of actions when specific circumstances arise; you specify these actions by dragging instructions into place, just as you would to create any instruction set or template.</p> <p>Powerups for NINA 2.x is no longer supported.</p> <p>Comments, suggestions, etc. always welcome at the #sequencer-powerups channel on the NINA Discord server.  This document was last updated for Sequencer Powerups 3.22.0.0; however, some screenshots have not been updated since 3.13.1.0</p> <p>Version history here</p> <p>If you're happy with Sequencer Powerups, you can always Buy me a coffee!</p> <p>Marc</p>"},{"location":"CVE/","title":"Constants/Variables/Expressions","text":""},{"location":"CVE/#expressions","title":"Expressions","text":"<p>An Expression in Sequencer Powerups is pretty much any kind of mathematical expression using numbers (fixed or floating point), Constants, and Variables, plus Device Data (various data from your devices); currently supported Device Data values are documented below.  Note that Device Data values are only available if the appropriate gear is connected!</p> <p>Expressions can be used in \"enhanced\" instructions (enhanced in the sense that they accept Expressions in place of numbers), as well as some new instructions like If and Loop While. Enhanced instructions are named with \"+\" appended to the instruction name (e.g. Take Exposure +, Cool Camera +, etc). So, for example, in Take Exposure +, the value of Exposure Time might be <code>10</code> or <code>ExpTime</code> (assuming <code>ExpTime</code> is defined as a Constant or Variable; see below) or even <code>ExpTime / 3</code> or a conditional like <code>if (rgb, ExpTime, ExpTime*2/3)</code>.  In the latter case, the \"if\" predicate takes three arguments: something can be tested for true/false (1/0), a value if \"true\", and a value if \"false\".</p>"},{"location":"CVE/#whats-valid-in-an-expression","title":"What's Valid in an Expression","text":"<p>Valid tokens in Expressions include numbers, parentheses, function and operator names (see Appendix), Constant and Variable names, the names of gauges, switches, and other Device Data (if these devices are connected in NINA), and the reserved names TIME,  SAFE, and EXITCODE (see ReservedVariables).</p>"},{"location":"CVE/#constants","title":"Constants","text":"<p>A Constant in Powerups is created using the Constant instruction; enter a name for the Constant and a value, which can be any valid expression (if the value refers to another Constant, that Constant needs to have been defined in the same instruction set or in a parent of the instruction set).  The Constant instruction is self-executing and continuously re-evaluated!  This means that Constants are \"live\" as they are read into the sequencer, and their values update as required, based on changes to other Constants that might have been referred to.  When the Sequencer executes a Constant instruction, literally nothing happens!  Note: A Constant definition cannot reference Variables and Device Data, as these - pretty much by definition - can change at any time!</p> <p>The value of a Constant can be changed at any time (even when a Sequence is running) and all references to that Constant are updated semi-immediately (within a couple seconds).  It's not a very good constant, is it?</p> <p></p> <p>Note that the calculated value of an Expression is shown in braces next to the Expression defining it. The value is shown in green if valid, and orange if not. Note that Constant (and Variable) names are case sensitive.</p> <p>Constants have block scope, which means that a Constant has a value in the instruction set that includes it, as well as instruction sets \"below\" it in the hierarchy of instructions (i.e. nested within the \"block\" of instructions in which it appears).  If a Constant X is defined in one instruction set, and a Constant X is also defined in a \"lower\" instruction set, the closest definition of X is used when that Constant is referenced.  Many computer languages use block scope for variables.  Below, the Take Exposure + instruction takes exposure time from the definition of <code>A</code> inside the same instruction set.</p> <p></p> <p>Global Constants are Constants that are valid everywhere in a sequence; they are set up in the Sequencer Powerups plugin page. They are described in more detail elsewhere in this document.</p>"},{"location":"CVE/#variables","title":"Variables","text":"<p>A Variable in Powerups is more similar to a traditional computer language variable; it also uses \"block scope\" (except for Global Variables; see below).   A Variable is defined using the Variable instruction, which is entirely analogous to the Constant instruction, except that Variable definitions are not self-executing - the Variable does not have a value prior to the execution of the Variable instruction.   References to a Variable \"below\" it in the code will show <code>Not evaluated: &lt;varname&gt;</code> until the Variable instruction gets executed. The Set Variable instruction can be used to change the value of a previously defined Variable.  For a value, any Expression can be used - including the use of Constants and Variables that have been previously defined.  The simplest form of this might this:</p> <p></p> <p>Just as in a procedural computer language, if you are looping through an instruction set, any Variables defined in that instruction set are reset to having no value before the loop repeats!</p> <p>Note: During sequence execution, the value of a Variable can be changed by editing the \"Currently\" field in the instruction.  If the sequence is also modifying the Variable, the results are unpredictable</p>"},{"location":"CVE/#variable-instructions","title":"Variable Instructions","text":"<p>Variable : Creates and defines the initial value of a Variable when it is executed.  Variables can have values that are either numbers or strings; strings must be enclosed in quotation marks (e.g. 'Value')</p> <p>Set Variable : Redefines the value of a previously created Variable</p> <p>Set Variable to Date : Redefines the value of a previously created Variable to a date and time, using the same mechanism as the built-in Loop Until Time interface (i.e. clock time, and time offset from meridian and the various forms of sunrise and sunset).  Note: Internally, dates are represented by an integer, the number of seconds from midnight January 1, 1970 UTC</p> <p>Global Variable : Creates and defines a Variable that can be used anywhere in a sequence, once the instruction has been executed.  Global Variables are the only variables that can be used across sequencer sections (where a section is one of \"Start Area\", \"Target Area\", and \"End Area\").  The value of a Global Variable can be changed with either of the two instructions above (Set Variable and Set Variable to Date).</p>"},{"location":"CVE/#embedded-instructions","title":"Embedded Instructions","text":"<p>Many Powerups include what I call Embedded Instructions; these are NINA instructions that are embedded within the Powerups instruction, in much the same way that instructions are embedded in NINA's instruction sets.  A typical example is the If instruction (documented just below).  When an If is dragged into a sequence, it looks like this:</p> <p></p> <p>To add Embedded Instructions, you simply drag them into the space marked \"Conditional instructions go here\", as below.  In the following example, the two embedded instructions will be executed when WindGust is greater than 5.</p> <p></p> <p>To save screen real estate, Embedded Instructions can be hidden with the arrow at the upper left of the instruction.</p> <p></p>"},{"location":"CVE/#captured-instructions","title":"Captured Instructions","text":"<p>Another concept Powerups uses is the idea of a Captured Instruction.  Instructions that use this concept work on another NINA instruction, executing it and (usually) acting on the result.  Here's one...</p> <p></p> <p>The If Failed instruction, for example, executes its Embedded Instructions if the execution of the Captured Instruction fails.   Here I am dragging a Run Autofocus instruction into the If Failed.</p> <p></p> <p>And here's how it looks with the Run Autofocus as the Captured Instruction, and with a Send to Pushover instruction added as an Embedded Instruction.   If the Run Autofocus fails, the message will be sent by Pushover...</p> <p></p>"},{"location":"CVE/#if-ifthenelse-instructions-when-trigger-loop-while-condition-wait-until-instruction-and-for-each-instruction","title":"If, If/Then/Else (instructions), When (trigger), Loop While (condition), Wait Until (instruction) and For Each (instruction)","text":""},{"location":"CVE/#if-and-ifthenelse","title":"If and If/Then/Else","text":"<p>The If instruction evaluates the given Expression and runs the specified instructions if that Expression is not false (not 0 or \"false\").  The If/Then/Else instruction adds the ability to specify instructions to execute if the Expression is false (or 0).</p> <p></p>"},{"location":"CVE/#when","title":"When","text":"<p>The When trigger is activated when the given expression is not false (not 0 or \"false') and runs the specified instructions. There is a Once Only toggle in this instruction; setting this to ON will cause this trigger to run only once during execution of your sequence. There is also a Interrupt toggle; if set to 'ON' (the default), the When trigger will interrupt any instruction in progress (the check is performed approximately every 5 seconds).</p> <p>The Interrupt functionality of the When trigger is unlike traditional NINA triggers that only run between the execution of instructions!</p>"},{"location":"CVE/#warnings-for-the-when-trigger","title":"Warnings for the When Trigger","text":"<p>If you don't somehow arrange for the Expression to become false during the execution of the included instructions, the When trigger will run every five seconds (after finishing those instructions).  If you want to keep this from happening, set the Once Only toggle to ON!</p> <p></p>"},{"location":"CVE/#loop-while","title":"Loop While","text":"<p>Loop While is a standard NINA \"Conditional\" and gets placed with other conditionals in an instruction set.   When queried (every 5 seconds or so while a sequence is running), it evaluates the given Expression and terminates the loop if the result is \"false\" or 0.</p> <p>Here\u2019s an example of a very simple instruction set using Variable, Set Variable, and Loop While.  Note that the Variable instruction needs to be outside the loop; otherwise the <code>Lp</code> variable will be reset to 10 every time the loop is restarted!</p> <p></p> <p>Note the white \"i\" (for \"Information\") icon in the Loop While instruction.  Hovering over this icon will show all of the Device Data that can be used in the Expression (this appears everywhere an Expression can be used). Here's what this might look like for you, depending on what devices you have connected at the time:</p> <p></p> <p>Here's an interesting example that uses these instructions to implement a timeout. The Loop While is basically running for up to 60 seconds OR until the confirmed Variable becomes true.  Each time through the loop, the If instruction checks whether a switch (in this case, GuideScopeOpen) has become \"true\"; if so, the Set Variable instruction sets confirmed to true.  This ends the loop.</p> <p></p> <p>Presumably, when this loop finishes, another test of GuideScopeOpen will be used to determine whether the opening procedure has succeeded. If not, perhaps a Ground Station plugin message will be sent, or the sequence terminated.</p>"},{"location":"CVE/#wait-until","title":"Wait Until","text":"<p>Wait Until is complementary to Loop While.  The instruction will wait until the given Expression is \"true\" (no longer \"false\" or 0).</p> <p>Here\u2019s an example of a very simple instruction set using Variable, Set Variable, and Loop While.  Note that the Variable instruction needs to be outside the loop; otherwise the <code>Lp</code> variable will be reset to 10 every time the loop is restarted!</p>"},{"location":"CVE/#for-each","title":"For Each","text":"<p>The For Each instruction allows for the creation of loops through lists of Expression values; the current implementation seems to work properly, though the UI is somewhat constrained.  When you load a For Each instruction into the sequencer, and open the container, you'll see this:</p> <p></p> <p>The Assign Variables instruction is created automatically, and should be left where it is - at the top of the instructions inside For Each.</p> <p>In a For Each instruction, you can specify a Variable to use, and then a series of values for that Variable; each, in turn, is assigned to the Variable on each iteration of the loop.  In the screenshot, the Variable <code>ExpTime</code> is set, in turn, to <code>30, 60, 120, 180, 240, and 300.</code> ` Note: You must define the Variable before the For Each instruction, as shown below </p> <p>Note: Expressions can be used for values; however, at the moment, the current value of the Expression is not shown in the UI</p> <p>Note: The \"progress\" indicator the screenshot below shows \"0/6\", indicating that there are six iterations of the loop to be executed.</p> <p></p> <p>It's possible to assign any number of Variables in each iteration of the loop.  The syntax (see the screenshot below) is that Variable names are separated by a comma, and that sets of assigned values are separated by a semicolon.  In the example below, the Variables <code>ExpTime</code> and <code>Gain</code> are set each time through the loop first to 30 and 0, respectively, then to 60 and 0, then to 120 and 100, etc.</p> <p></p> <p>For Each instructions can be nested (of course).  The sequence below will image 20 darks at 8 different exposure times and 2 different gains.</p> <p></p>"},{"location":"CVE/#constantvariable-container","title":"Constant/Variable Container","text":"<p>A Constant/Variable Container is a special kind of container that can hold only Constant, Variable, and Annotation instructions.  Its intended use is to \"clean up\" sequences with many Constant and Variable definitions.  What makes this container special is that Constants and Variables defined within it act as though they were defined at the level of the container (or Template by Reference) that they are enclosed in.</p> <p>In the example below, the Constant X2 definition, using the Constant X, would be undefined if X had not been defined in the Constant/Variable container used in the Template by Reference.</p> <p></p> <p>In a regular sequential instruction set, the Variable X is not in scope when evaluating X2.</p> <p></p>"},{"location":"CVE/#imaging-page-dockable","title":"Imaging Page Dockable","text":"<p>There is a dockable panel in the Imaging page of NINA that can be used to \"watch\" any number of Expressions in real-time.  These can include any of your Constants, Variables, Device Data, etc.   Basically, an all-in-one data display for Powerups.</p> <p></p>"},{"location":"CVE/#reserved-variables","title":"Reserved Variables","text":"<p>The following Variable/Constant names are reserved:</p> <p>SAFE \u2002 - \u2002 See the documentation for \"Safety\"</p> <p>TIME \u2002 - \u2002 The current time in seconds since NINA was started, with an accuracy of 10 seconds or so. This is not intended, obviously, for highly accurate timing, but can be used, for example, with the When trigger to take actions at various intervals.</p> <p>EXITCODE \u2002 - \u2002 The EXITCODE from a call to the External Script + command (see later in this document)</p>"},{"location":"CVE/#device-data","title":"Device Data","text":"<p>The following Device Data is available if the associated device is connected in NINA.  Note that this list is added to frequently, often upon request by users.</p> <p>Astrometry data: SunAltitude, SunAzimuth, MoonAltitude (no device needed)</p> <p>Camera data: SensorTemp</p> <p>Camera data (hidden): camera__PixelSize, camera__XSize, camera__YSize, camera__CoolerPower, camera__CoolerOn</p> <p>Dome data:  DomeStatus, DomeAzimuth</p> <p>DomeStatus constants: ShutterNone, ShutterOpen, ShutterClosed, ShutterOpening, ShutterClosing, ShutterError</p> <p>Filter Wheel data: CurrentFilter</p> <p>CurrentFilter constants: Filter_name, where \"name\" is the name of the filter with all non-alphanumeric characters removed.  So a filter named \"My IR Filter\" must be referred to as Filter_MyIRFilter.</p> <p>Flat Device data: CoverState</p> <p>CoverStatus constants: CoverOpen, CoverClosed, CoverNeitherOpenNorClosed, CoverUnknown, CoverError</p> <p>Last Image data: Image_HFR, Image_StarCount (if Hocus Focus is being used for star analysis, Image_FWHM and Image_Eccentricity are also available)</p> <p>Roof data: RoofStatus</p> <p>RoofStatus constants: RoofOpen, RoofNotOpen, RoofCannotOpenOrRead (note: RoofStatus requires the use of a RoofStatus file that can be defined in the Powerups settings)</p> <p>Rotator data: RotatorMechanicalPosition, RotatorPosition (these are the same)</p> <p>Safety Monitor data: IsSafe</p> <p>Telescope (Mount) data: Altitude, Azimuth, RightAscension, Declination, AtPark, SideOfPier</p> <p>SideOfPier constants: PierEast, PierWest, PierUnknown</p> <p>Target data: TargetName (if a Target is being used)</p> <p>Target Scheduler Plugin data:  TS_TargetName, TS_ProjectName, TS_WaitTime (Note: These are available depending on whether Target Scheduler has published those values)</p>"},{"location":"CVE/#odds-and-ends","title":"Odds and Ends","text":"<p>\u2022   Wherever Expressions are used, the current value of that Expression is shown in brackets { }, in green if valid and in orange if invalid (not defined, etc.)  These colors are currently fixed, and only appear nicely in certain color schemes; sorry about that!  Here's a rather useless example:</p> <p></p> <p>\u2022   Up to 10 Global Constants can be defined on the plugin page; each of them can be set for all of your NINA Profiles, or can be set on a per-profile basis.</p> <p></p> <p>\u2022   Hovering over an Expression will show the current value of any Constants and Variables that are used in that Expression.  In the example below, the Constant A is defined \"Here\" (meaning in the current block) and has a value of 8; the Constant CHATTER is defined globally and has a value of 200.</p> <p></p> <p>\u2022   If and Loop While instructions show the current result of the Expression.</p> <p>\u2022   There is a Breakpoint instruction that stops sequence execution until you press the \"Continue\" button that appears when a breakpoint is hit.  The Breakpoint instruction is exactly equivalent to Wait for Time Span of twelve hours.</p> <p></p>"},{"location":"CVE/#summary","title":"Summary","text":"<p>Constants have the same value throughout a sequence (in their scope) and do not change during sequence execution (or more precisely are not changed because of sequence execution).  A human can change them, and that change takes effect immediately, but the sequence itself does not change them.  Variables, on the other hand, are created and changed by sequence execution, without human intervention.  However, you can always manually change the values of both Variables and Constants during execution, just as you can reorder instructions and do other dastardly things to yout sequence (with great power comes great responsibility).  Just remember that manual changes can have side effects that might be unexpected!</p>"},{"location":"CVE/#appendix-functions-and-operators-in-expressions","title":"Appendix: Functions and Operators in Expressions","text":"<p>These are the valid functions that can be used in Expressions.</p> Method Description <code>Abs</code> Returns the absolute value of a specified number <code>Acos</code> Returns the angle whose cosine is the specified number <code>Asin</code> Returns the angle whose sine is the specified number <code>Atan</code> Returns the angle whose tangent is the specified number <code>Ceiling</code> Returns the smallest integer greater than or equal to the specified number <code>Cos</code> Returns the cosine of the specified angle <code>Exp</code> Returns e raised to the specified power <code>Floor</code> Returns the largest integer less than or equal to the specified number <code>Log</code> Returns the logarithm the specified number <code>Log10</code> Returns the base 10 logarithm the specified number <code>Max</code> Returns the larger of two specified numbers <code>Min</code> Returns the lesser of two specified numbers <code>Pow</code> Returns the specified number raised to specified power <code>Round</code> Rounds a value to the nearest integer or specified number of decimal places <code>Sign</code> Returns a value indicating the sign of a number <code>Sin</code> Returns the sine of the specified angle <code>Sqrt</code> Returns the square root of the specified number <code>Tan</code> Returns the tangent of the specified angle <code>Truncate</code> Calculates an integral part of a number <code>if</code> Returns either then or else depending on whether expr is true or not - if(expr, then, else) <code>in</code> Returns true or false depending on whether expr is one of the following - in(expr, a, b, c) Date/Time Description <code>now</code> Returns the current date/time <code>hour</code> Returns the hour (Midnight = 0, 11PM = 23) <code>minute</code> Returns the minute of the hour <code>day</code> Returns the day of the month <code>month</code> Returns the month (January = 1) <code>year</code> Returns the year <code>dow</code> Returns the day of the week (Sunday = 0) <p>Here are the valid operators in Expressions</p> Method Description <code>Arithmetical</code> - , \u2002 + ,\u2002  *,\u2002 /,\u2002 % <code>Logical</code> &amp;&amp;, \u2002 ||, \u2002  ! <code>Bitwise</code> &amp;, \u2002|,\u2002 ^, \u2002~, \u2002&lt;&lt;,\u2002 &gt;&gt; <code>Comparison</code> ==,\u2002!=,\u2002 &gt;,\u2002 &lt;,\u2002 &gt;=, \u2002&lt;="},{"location":"DArrays/","title":"Arrays","text":"<p>Powerups provides a simple facility for creating and using one-dimensional arrays.  Powerups Arrays aren't traditional arrays in the computer language sense (an ordered structure, typically starting with index 0), but rather an associative array, or dictionary, whose index and value can be either numeric or a string (within single quotes).  When looping through an Array, values will be retrieved in arbitrary order, unless they have numeric indices.</p>"},{"location":"DArrays/#array-names","title":"Array Names","text":"<p>Array names are strings, alphanumeric characters surrounded by single or double quotes, e.g. 'MyArray'.  They are not Variables or Constants, and cannot be used like them.</p>"},{"location":"DArrays/#initialize-array","title":"Initialize Array","text":"<p>This instruction creates or re-initializes an already created Array; after this instruction is executed, the Array can be used in other instructions (below).  An initialized Array has no contents.</p> <p></p> <p>Note that the name of the Array can either be a literal string (in quotes) or a Variable whose value is a literal string.</p>"},{"location":"DArrays/#put-into-array-get-from-array","title":"Put into Array / Get from Array","text":"<p>These two instructions do pretty much what you'd expect; inserting and retrieving elements of the Array.</p> <p></p>"},{"location":"DArrays/#for-each-in-array","title":"For Each in Array","text":""},{"location":"DArrays/#functions-that-can-be-used-with-arrays","title":"Functions that can be used with Arrays","text":"<p>length('array') returns the number of elements in the Array</p> <p>sumOfValues('array') returns the sum of all of the elements in an Array</p> <p>averageOfValues('array') returns the average of all of the (numeric) elements in an Array</p>"},{"location":"DIY%20Meridian%20Flip/","title":"DIY Meridian Flip","text":"<p>DIY Meridian Flip is a Trigger that effectively \"deconstructs\" the standard NINA Meridian Flip Trigger.  The best way to describe this is to show what it looks like when you first expand this trigger:</p> <p></p> <p>Note that \"inside\" the trigger are eight NINA instructions that correspond to the actions that NINA takes during a Meridian Flip. Most of these instructions are standard in NINA, with the exception of two that are not normally exposed in NINA.  These are:</p> <p>1) Wait to Pass Meridian  This instruction, as it implies, waits until your target (or telescope, if there's no active target but your mount is tracking) crosses the Meridian and is, therefore, presumably ready to \"flip\"</p> <p>2) Do Flip  This instruction actually performs the \"flip\", which is done by slewing the telescope to the target's current position (if, indeed, your mount is past the Meridian, this should cause the flip to occur).  Note that NINA cannot actually \"flip\" the scope; your mount must be set up so that a flip will occur when required.</p> <p>As with many of the other Powerups instructions, you can feel free to change the order of the instructions inside DIY Meridian Flip, remove or add instructions, etc.  It is your responsibility to make sure the instructions, and their ordering, make sense!  For example, putting Do Flip before Wait to Pass Meridian is likely to be a bad mistake.</p> <p>Note also that \"Pause Before Meridian\", \"Minutes After Meridian\", and \"Max Minutes After Meridian\" settings in DIY Meridian Flip take, as their default, the standard NINA settings for Meridian Flip; however, you can change these to override those settings.</p>"},{"location":"Enhanced%20Instructions/","title":"Enhanced Instructions","text":"<p>Enhanced Instructions are built-in NINA instructions that have been enhanced to allow the use of Expressions.  These instructions take the name of the existing NINA instruction and put a plus-sign (+) at the end.  More instructions will be enhanced in the future.</p>"},{"location":"Enhanced%20Instructions/#take-exposure-take-many-exposures-and-smart-exposure","title":"Take Exposure +, Take Many Exposures +, and Smart Exposure +","text":"<p>These imaging instructions allow Expressions for number of exposures, exposure time, gain, offset, and dither.  In the examples below, the Constants used are defined elsewhere. Note: Filter, and binning are planned for the future.</p> <p></p>"},{"location":"Enhanced%20Instructions/#trained-flat-exposure-trained-dark-flat-exposure","title":"Trained Flat Exposure +, Trained Dark Flat Exposure +","text":"<p>These imaging instructions allow Expressions for number of exposures, gain, and offset.  In the examples below, the Constants used are defined elsewhere. </p> <p></p>"},{"location":"Enhanced%20Instructions/#cool-camera","title":"Cool Camera +","text":"<p>This instruction can use Expressions both for the set temperature and duration.</p> <p></p>"},{"location":"Enhanced%20Instructions/#move-focuser-relative-move-focuser-absolute","title":"Move Focuser Relative + / Move Focuser Absolute +","text":""},{"location":"Enhanced%20Instructions/#switch-filter","title":"Switch Filter +","text":"<p>Allows use of an Expression to specify a filter.   Note that filter names are represented by <code>Filter_filterName</code>, where <code>filterName</code> is the name of a filter without spaces or other punctuation.</p> <p></p>"},{"location":"Enhanced%20Instructions/#move-rotator-mechanical","title":"Move Rotator Mechanical +","text":"<p>Use an Expression to specify a mechanical rotator angle.</p> <p></p>"},{"location":"Enhanced%20Instructions/#slew-to-radec-slew-to-radec-and-center-slew-to-altaz","title":"Slew to RA/Dec, Slew to RA/Dec and Center +, Slew to Alt/Az","text":"<p>Slew to RA/Dec (or Alt/Az) using an Expression to specify decimal coordinates, and (optionally) center.</p> <p></p>"},{"location":"Enhanced%20Instructions/#smart-subframe-exposure","title":"Smart Subframe Exposure +","text":"<p>This is an enhancement to Smart Exposure + in which a subframe can be specified.  There are two options - ROI % or Dimensions, as shown below.  Note that a warning will be shown if the connected camera does not support subframe exposures.</p> <p></p>"},{"location":"Enhanced%20Instructions/#external-script","title":"External Script +","text":"<p>This is fully documented elsewhere in this document.</p>"},{"location":"Enhanced%20Instructions/#wait-for-time-span","title":"Wait for Time Span +","text":"<p>Allows use of an Expression to specify a wait time (in seconds)</p> <p></p>"},{"location":"Enhanced%20Instructions/#annotation","title":"Annotation +","text":"<p>This instruction allows the use of Expressions within the annotation; each Expression must be surrounded by {}'s.</p> <p></p>"},{"location":"Safety/","title":"Safety","text":"<p>Sequencer Powerups has a number of instructions that help with the handling of safe/unsafe conditions. All of these instructions require that an ASCOM-compilant Safety Monitor is connected to NINA.</p> <p>Generally, imagers will want to execute some kind of \"subroutine\" when their gear becomes \"unsafe\", and then  return to their imaging if and when their gear becomes \"safe\" again. The following instructions were designed exactly for this purpose.</p>"},{"location":"Safety/#when-becomes-unsafe","title":"When Becomes Unsafe","text":"<p>The When Becomes Unssafe trigger allows you to specify a set of instructions to execute within a couple of seconds of your gear becoming \"unsafe\". Typically, these intructions might include Close Dome Shutter, Park Scope, an instruction to send yourself a notification (as with the Ground Station plugin), and things of that sort.</p> <p></p>"},{"location":"Safety/#once-safe-and-wait-for-safe","title":"Once Safe and Wait for Safe +","text":"<p>One of these two instructions will almost always be used after the instructions that put your gear into a safe configuration.</p>"},{"location":"Safety/#once-safe","title":"Once Safe","text":"<p>The Once Safe instruction is the preferred way of continuing to image after When Becomes Unsafe is triggered.  As with When Becomes Unsafe, you add instructions within Once Safe that get your gear ready to continue imnaging.  Typically, this would include instructions to open a dome, unpark your mount, slew back to your target, start guiding, perhaps autofocus, etc.   When the last of these instructions is executed, NINA will go right back to what it was doing when WBU was initially executed.   The screenshot above shows the use of When Becomes Unsafe with Once Safe.</p>"},{"location":"Safety/#wait-for-safe","title":"Wait for Safe +","text":"<p>The Wait for Safe+ instruction can also be used within the When Becomes Unsafe instruction; this, as you'd expect, simply waits for conditions to become safe again and then continues, typically with instructions, as with Once Safe, that prepare your gear for continued imaging.</p> <p>I strongly recommend using Once Safe as opposed to Wait for Safe +</p>"},{"location":"Safety/#looping-considerations","title":"Looping Considerations","text":"<p>It's important to note that looping conditions are honored during the execution of a When Becomes Unsafe instruction, thereby allowing your sequences to naturally terminate cleanly even if conditions never become safe again.  For example, in the case below, tne When Becomes Unsafe will stop when the Loop Until Time expires at Astronomical Dawn, even if the sequencer is sitting in a Once Safe or a Wait until Safe + instruction.</p> <p></p>"},{"location":"Safety/#reentrancy","title":"Reentrancy","text":"<p>When Becomes Unsafe has been designed for reentrancy - tnat is, if conditions become unsafe again during execution of the trigger (including while in the midst of Once Safe or after a Wait for Safe+), tne When Becomes Unsafe will restart itself. When Becomes Unsafe can be used over and over within a Sequence.</p>"},{"location":"Safety/#the-safe-variable","title":"The SAFE Variable","text":"<p>Typically, the concept of safety in NINA depends upon having a connected Safety Monitor device that can report conditions as being \"safe\" or \"unsafe\". Indeed, all of the safety-related instructions in Powerups typically use this in determining the current safety status of your gear. However, there are cases in which a NINA user may wish to simulate the preence of a safety monitor using other data, for example a weather reporting device. To allow for these cases, Powerups will, in addition to the state of a Safety Monitor, look to see if a Variable named SAFE (all uppercase) is defined.  If it is, its value is used to determine whether conditions are safe or unsafe, regardless of the state of a connected Safety Monitor. The table below shows how Powerups behaves depending on the states of a Safety Monitor and the SAFE Variable.</p> Safety Monitor SAFE Variable Result Safe Undefined or true Safe Safe Defined and false Unsafe Unsafe Undefined or false Unsafe Unsafe Defined and true Safe Not connected Undefined or true Safe Not connected Defined and false Unsafe"},{"location":"TBR/","title":"Template by Reference","text":""},{"location":"TBR/#template-by-reference-rationale","title":"Template by Reference - Rationale","text":"<p>If you use NINA Templates in your sequences, you'll find that Template by Reference is one of the most powerful features of Sequencer Powerups. In effect, they turn your Templates into something more akin to \"subroutine calls\" or \"macros\". It's easiest to show this with examples.</p> <p>Let's say you have a startup Template like this that cools the camera, slews and centers the target, and runs autofocus:</p> <p></p> <p>If you use this in different Templates, Targets, or Sequences (I'll just call all of these \"sequences\" for simplicity), you'll have these three instructions repeated in each of them. Now let's say you add something new to your startup procedure, like opening an automated flat cover. To update your existing sequences, you'll have to go into each one and add the new instruction. Not only is this tedious, it's also very error prone - you might make a mistake in updating some sequences, for example, or you might simply forget to update some sequences altogether.</p> <p>With Template by Reference, all of this repetition goes away.  Simply add the instruction to your Sequences, and use the picker to select the Template you want to reference.  So now you have this:</p> <p></p>"},{"location":"TBR/#usage","title":"Usage","text":"<p>When using a Template by Reference instruction in a sequence, you can use the arrow on the left side of the instruction to expand it.</p> <p></p> <p>Let's say I now want to update my Startup Template by adding an instruction for my new flat device. After the simple edit, it might look like this:</p> <p></p> <p>Now, save the Template as you usually would, by clicking on the floppy disc icon on the right side of the screen.  Having done this, and if you are using Template by Reference specifying Startup Template in other sequences, you will find that they will all be using the updated version of Startup Template.</p> <p>Extra credit for recognizing the idiocy of where I added the Open Flat Panel Cover instruction</p> <p>Note: Template by Reference does not work when loading a startup sequence from the command line!</p>"},{"location":"TBR/#how-does-this-work","title":"How Does This Work?","text":"<p>To use Template by Reference to its fullest potential, it helps to understand how it works. And it's really very simple. The Template by Reference instruction simply refers to the specified Template by its name.</p> <p>The \"magic\" comes when you load a sequence with one or more Template by Reference instructions into the Advanced Sequencer; at that time, all Template by Reference instructions copy in the most recent version of the referenced Template into the sequencer. At that point, it is exactly as though you copied the Template into your sequence, and you can edit it, save it, or just use it as is.</p> <p>If you edit the contents of a Template by Reference that you've expanded in a sequence, those changes are local; they do not propagate to other sequences. But what if you want to make changes and have those changes be \"seen\" by other sequences? That's simple: just save the Template as you would save any other template.</p> <p>Again, this all makes sense if you remember that Template by Reference copies the Template into your sequence when it is loaded into the Advanced Sequencer.</p>"},{"location":"TBR/#confused","title":"Confused?","text":"<p>At first, some of this might seem confusing, though I've tried to make it comprehensible. If you have questions, please don't hesitate to ask on the #sequencer-powerups channel in the NINA Discord.</p>"},{"location":"TBR/#functions","title":"Functions","text":"<p>Functions are Templates that can be called with up to six arguments, and can return a value (by setting a Variable).  They are similar to Template by Reference in that they refer to a Template by name, but they act somewhat differently as will be described below.</p>"},{"location":"TBR/#what-are-they-for","title":"What are They For?","text":"<p>I'm not really sure, so I'm hoping you'll let me know if you find a use for them (other than demonstrating the power of NINA's plugin system).</p>"},{"location":"TBR/#the-call-and-return-instructions","title":"The Call and Return instructions","text":"<p>The Call instruction can specify up to three arguments, and a Variable name that can store a return value.  All three arguments, as well as the return value, are optional.  A Call with neither arguments nor a return value is simply another way of executing a Template.  Arguments can be passed by value or by reference.  To pass an argument by reference, use an underscore as a prefix before the name of the Variable.   So the argument \"Count\" refers to the value of the Count Variable; the argument <code>_Count</code> refers to a reference to the Count variable. For those unfamiliar with the concept of a \"reference\" (also called a \"pointer\"), read on.</p> <p>A Function is just a Template, but when it's used, there are some differences:</p> <p>1) The template is loaded when it is called, which is unlike Template by Reference (TBR) which loads the template when the TBR is loaded into the sequence.</p> <p>2) The Variables Arg1, Arg2, etc. are assigned to the arguments specified in the Call instruction (all are optional). If an argument is of the form <code>_xxx</code>, where xxx is the  name of a Variable, then the argument is passed as a reference to the Variable specified.</p> <p>3) The (new) Return instruction can be used at any time in the Template to cause the called Template to return.  If a value is included in the Return instruction, and if there is a Variable specified in the Call instruction, that Variable will be assigned the Return value.</p> <p>Here's an example of an argument passed by value.  Below, the code has run; the Template \"ReferencedFunc\" has been called, and the Loop While has run 10 times, ending with <code>Arg1</code> having a value of zero.  The Loop While expression is false.</p> <p></p> <p>Here's the same example, but the argument is passed as a reference to the Variable V.  The result is very similar; the Loop While runs 10 times, the Arg1 Variable decrements to zero, but notice that the reference Variable V is now also zero.   That's because, while executing the Template, the instruction Set Variable of Arg1 is actually setting the value of Variable V that Arg1 references.  The distinction is important!</p> <p></p> <p>And here's the Template \"ReferencedFunc\".  You'll notice that the Variable Arg1 appears undefined, which makes sense actually; it will get defined automatically when the Template is Called.</p> <p></p>"},{"location":"TBR/#recursion","title":"Recursion","text":"<p>Yes, Powerups Functions can be recursive.  Here's a Template called \"Fact\" that calculates \"factorial\" of its argument.</p> <p></p> <p>And here's 8! (8 factorial, as calcualted by the Sequencer)</p> <p></p>"},{"location":"TBR/#appendix-what-are-sequences-and-templates-anyway","title":"Appendix: What are Sequences and Templates Anyway??","text":"<p>There is often a great deal of confusion with what is meant by a Sequence, as opposed to a Template in NINA (And then there are Targets, but you're on your own there).</p>"},{"location":"TBR/#templates","title":"Templates","text":"<p>A NINA Template is an instruction set that you have saved with the instruction set's floppy disk button. Here are the built in types of instruction set, along with another one (Variable Star object container) that was created by a plug-in.</p> <p></p> <p>You can see the floppy disc icon here on the right side of the screen:</p> <p></p> <p>When you save an instruction set with the floppy disc button, a Template is created with a name you can choose. In the example above, the name of the Template would be named \"Parallel Instruction Set\" (not a very good name). Note that the state of the Template is not saved; all loop counts, exposure counts, and the like are reset when the Template is saved!</p> <p>A Template can contain any number of instructions, instruction sets, Templates, and Targets,</p> <p></p>"},{"location":"TBR/#sequences","title":"Sequences","text":"<p>Sequences in NINA represent the entire contents of the Advanced Sequencer at any given point in time; that is, it includes the \"Sequence Start Area\", the \"Sequence Target Area\", and the \"Sequence End Area\".  They are loaded and saved with icons at the lower left of the Advance Sequencer. Note: When you save a Sequence, the state of the Sequence is preserved - that means that loop counters, exposure counts, and the like are remembered and restored when that Sequence is loaded!</p> <p></p> <p>These things are described more fully, but with some inconsistencies in terminology, at NINA Advanced Sequencer</p>"},{"location":"Triggers/","title":"Triggers","text":"<p>Sequencer Powerups defines four new Triggers that can be helpful in some circumstances.</p>"},{"location":"Triggers/#diy-trigger","title":"DIY Trigger","text":"<p>NINA Triggers \"fire\" between the execution of instructions in a Sequence if the triggering condition is met (note that the When and When Becomes Unsafe Triggers in Sequencer Powerups act differently; they will \"fire\" within seconds of the condition being met).  Triggers internally have two parts: 1) checking the condition, and 2) taking some appropriate action or actions.</p> <p>So, for example, the built-in Meridian Flip Trigger, between instructions, 1) checks if it's time for a Meridian Flip, and 2) if it is, takes the requisite actions - stop guiding, wait to pass the meridian, slew back to the target, etc.</p> <p>The DIY Trigger deconstructs the two parts of a Trigger.  You get to specify 1) the existing Trigger whose triggering condition you want to use, and 2) specify the instructions that NINA will execute when that triggering condition is met.</p> <p>In this simple example, we use the triggering condition of AF After HFR Increase; when triggered, we use Run Autofocus (to do the actual autofocus, but in addition we send ourselves an alert:</p> <p></p> <p>Note: When DIY Trigger is activated, only the Embedded Instructions are executed; there are no default or implicit actions taken!  In the example above, a Run Autofocus will only be done because it's one of the Embedded Instructions. </p>"},{"location":"Triggers/#safe-trigger","title":"Safe Trigger","text":"<p>This is exactly like DIY Trigger but the trigger will only trip if conditions are \"Safe\".</p>"},{"location":"Triggers/#autofocus-trigger","title":"Autofocus Trigger","text":"<p>There are times when, looking at your running sequence, you think that this would be a good time for running Autofocus (maybe something looks wrong with an image, or you worry that conditions have changed enough to require one right now).  This is what Autofocus Trigger is for; simply drop the trigger into your sequence, and an Autofocus will be run as soon as the currently executing instruction has finished.  Note that you should delete the instruction after the Autofocus has started!</p>"},{"location":"Triggers/#interrupt-trigger","title":"Interrupt Trigger","text":"<p>Interrupt Trigger is similar to Autofocus Trigger in that it trips after the currently running instruction (just drop it into Triggers); instead of running an Autofocus, you can specify whatever instruction(s) you like.  And, as with Autofocus Trigger, this is intended to be a one-time operation.</p>"},{"location":"Z/","title":"This &amp; That","text":"<p>Here are some other instructions you might find useful...</p>"},{"location":"Z/#repeat-until-all-succeed","title":"Repeat Until All Succeed","text":"<p>This instruction will loop through the included instructions until none of them fail.  This might be useful at startup time to make sure all of your equipment is running properly before starting imaging. As soon as any of the instructions fails, NINA will pause for the amount of time you specify and then try again.</p>"},{"location":"Z/#wait-indefinitely","title":"Wait Indefinitely","text":"<p>This instruction, well, waits indefinitely.</p> <p></p>"},{"location":"Z/#send-with-ground-station","title":"Send with Ground Station","text":"<p>Drag a Ground Station plugin instruction into this one, then specify a Title and Message.  The Message can include any number of Expressions surrounded by curly brackets.</p>"},{"location":"Z/#add-image-pattern","title":"Add Image Pattern","text":"<p>You provide a name for the pattern (e.g. FOO) and a new image pattern $$FOO$$ becomes available for use when you take images.  The Expression you provide in the instruction is evaluated when an image file is created, and that value is used as the value of the pattern you added.  Note: The pattern is added once a name, value (any Expression you like), and a description are added to the instruction. Note: The instruction is self-executing, like Constant.  It does not need to be executed; just adding or loading it is enough. Note:  There's currently no way to change or remove a file pattern token, so if you change the name or description inside the Add Image Pattern instruction, nothing will happen (at least until you start NINA again) </p>"},{"location":"Z/#if-failed","title":"If Failed","text":"<p>Drag any instruction into the If Failed instruction; if that instructions fails, the enclosed instructions will be executed.</p>"},{"location":"Z/#if-timeout","title":"If Timeout","text":"<p>Drag any instruction or instruction set into the If Timeout instruction and specify an amount of time to allow for that instruction/instruction set to complete.  If the time is exceeded, the enclosed instructions will be executed.</p>"},{"location":"Z/#breakpoint","title":"Breakpoint","text":"<p>This is exactly the same as Wait Indefinitely except that it throws up a NINA warning.</p>"},{"location":"Z/#end-sequence","title":"End Sequence","text":"<p>This instruction ends the entire sequence that is running.</p>"},{"location":"Z/#end-instruction-set","title":"End Instruction Set","text":"<p>This instruction terminates the instruction you specify, anywhere in the hierarchy of running instructions.</p>"},{"location":"Z/#log-on-click","title":"Log on Click","text":"<p>This instruction allows you to add arbitrary text to the NINA log. This might be useful when reporting bugs in being able to mark the time and cicrumstance under which something or other happened.</p> <p>The Log on Click instruction can be put anywhere in a sequence; it does not get executed, ever.  To add your note to the NINA log, just enter text and, when you're ready, click on the button to the right of the text field (the icon looks like a pen).</p> <p></p>"},{"location":"Z/#flip-rotator","title":"Flip Rotator","text":"<p>Some users will need to flip the rotator position after a Meridian Flip; this instruction will flip the rotator by 180 degrees</p>"},{"location":"xternal%20Script%20%2B/","title":"External Script +","text":"<p>This is an enhanced version of the existing NINA instruction, External Script. The key difference is that now you can pass Variable values to a script and, even better, receive a value back into your sequence.</p> <p>The 'External Script' command allows you to execute a Windows batch file, enabling you to perform various tasks such as launching other programs, copying files at the end of a session, or terminating other Windows processes.</p> <p>External Script +' does the same with two enhancements, pass variable values to the called script and receive back a single value from the script in the new Variable (reserved word) EXITCODE.</p> <p>The EXITCODE can be in the range of -2147483648 to 2147483647 and is set in a script as the windows batch variable %ERRORLEVEL% by way of the script line EXIT /b</p>"},{"location":"xternal%20Script%20%2B/#passing-values-to-a-script","title":"Passing Values to a Script","text":"<p>There are two ways to pass data to an external script, as follows - </p> <p>In the form of a value substituted string: \"C:\\Users\\Bob\\Documents\\N.I.N.A\\scripts\\logger.bat\" \"HFR: {hfr}  Focus: {focuspos}  Temp: {temp}\" &gt;&gt; \"C:\\Users\\Bob\\Documents\\N.I.N.A\\scripts\\logger.log\" 2&gt;&gt;&amp;1</p> <p>In the form of discrete values: \"C:\\Users\\Bob\\Documents\\N.I.N.A\\scripts\\logger.bat\" {hfr} {focuspos} {temp} &gt;&gt; \"C:\\Users\\Bob\\Documents\\N.I.N.A\\scripts\\logger.log\" 2&gt;&gt;&amp;1</p>"},{"location":"xternal%20Script%20%2B/#breaking-down-the-external-script-command-line-into-its-components","title":"Breaking down the External Script + command line into its components:","text":""},{"location":"xternal%20Script%20%2B/#cusersbobdocumentsninascriptsloggerbat","title":"\"C:\\Users\\Bob\\Documents\\N.I.N.A\\scripts\\logger.bat\"","text":"<p>(Required) This is the fully qualified name of the batch file being called. If it contains a space it must be enclosed in quotes so its good practice to do that always. The script can be located anywhere on your system but a new subdirectory in Documents-&gt;N.I.N.A. is suggested</p>"},{"location":"xternal%20Script%20%2B/#hfr-hfr-focus-focuspos-temp-temp-or-hfr-focuspos-temp","title":"\"HFR: {hfr}  Focus: {focuspos}  Temp: {temp}\" or {hfr} {focuspos} {temp}","text":"<p>(Optional) The value substituted string or the discrete values are passed as batch command line input arguments to the script. The Variable names enclosed in curly braces {variable} are substituted with current Variable values.</p>"},{"location":"xternal%20Script%20%2B/#or","title":"&gt;&gt;  or &gt;","text":"<p>(Optional) Redirect STDOUT to a file. The &gt;&gt; format creates a new file if it does not exist or appends to an already existing file. The &gt; format erases any existing file and creates a new file.</p>"},{"location":"xternal%20Script%20%2B/#cusersbobdocumentsninascriptsloggerlog","title":"\"C:\\Users\\Bob\\Documents\\N.I.N.A\\scripts\\logger.log\"","text":"<p>(Required only for redirect above) The file name to which the STDOUT will be redirected. The output file can be located anywhere on your system. Its good practice to enclose the name in quotes in case there is a space in one of the directory names or file name. </p>"},{"location":"xternal%20Script%20%2B/#21","title":"2&gt;&gt;&amp;1","text":"<p>(Optional) Additionally redirect the windows STDERR to STDOUT. Any error message that may occur in the script will also be captured into the redirected output file </p> <p>The batch script file being called can set internal variables to the corresponding position of the passed values. A simple example of the logger.bat script referenced above with three value inputs would be as follows:</p> <p>@echo off set arg1=%1 set arg2=%2 set arg3=%3 echo %arg1% echo %arg2% echo %arg3%</p> <p>Any echo command causes the value to output to windows STDOUT and if being redirected to a file, will be added to the file.</p>"},{"location":"xternal%20Script%20%2B/#receiving-values-from-a-script","title":"Receiving Values from a Script","text":"<p>The value received from a script can be in the range of -2147483647 to 2147483647. </p> <p>The single value of low int -2147483648 is reserved for system use.</p> <p>There are two ways for a script to pass a value back into N.I.N.A</p> <p>1)  The first and standard way is via the system variable %ERRORLEVEL% which can be set either programmatically or with a specific value coded into the script. The script line: EXIT /b   passes the  back into \u2018External Script +\u2019 as the reserved variable EXITCODE.  The drawback to this method is that script variables cannot be used in place of value and any value must be hardcoded. This is a windows limitation that does not allows the user to manipulate the variable %ERRORLEVEL% <p>2)  The second method is to set a user environment variable named NINAESRC (NINA External Script Return Code) using the SETX command. Note the SETX syntax differs from SET in the way it assigns values. SETX does not use the equal (=) sign whereas SET does:</p> <p>set myvar=12345 setx NINAESRC %myvar%</p> <p>Sequencer Powerups will look to see if the user has set a value into NINAESRC and use that as that as the value assigned to EXITCODE.</p> <p>Note it is also possible to use the standard method with a variable if the range of vales to return is known and limited in number, using the form:</p> <p>set myretcode=4  if %myretcode% equ 1 exit /b 1 if %myretcode% equ 2 exit /b 2 if %myretcode% equ 3 exit /b 3 if %myretcode% equ 4 exit /b 4 if %myretcode% equ 5 exit /b 5 </p> <p>N.I.N.A. treats any non-zero return value from a script as an error. In reality the error value is data which can be assigned to a variable.</p> <p>The same capability to control execution on a non-zero return code exits as with \u2018External Script\u2019</p> <p></p> <p>But regardless of the action chosen, the new reserved word EXITCODE is set to the returned value and can be used in expressions or as a Variable value.</p> <p></p> <p>Testing on the value of EXITCODE</p> <p></p> <p>Assigning the value of EXITCODE to a Variable and using that value for example as a wait time in the new Wait for Time Span +git instruction</p>"}]}